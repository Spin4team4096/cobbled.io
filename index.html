<!DOCTYPE html>
<html>
    <title>Cobbled.io</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
<body style="margin:0; overflow:hidden;">
    <canvas id="game"></canvas>
    <input type="text" id="usernameInput" placeholder="Enter username..." maxlength="20" style="
        position: absolute;
        width: 200px;
        height: 22px;
        font-size: 16px;
        text-align: center;
        border: 2px solid #bfbfbf;
        background: #ffffff;
        color: #000000;
        display: none;
        z-index: 1000;
    ">

    <script>
        // TODO: (Apart from whatever is already in the comments)
        // - Make Crimson boulders have a red haze thing, and text on it
        // - Add local notification "Don't forget to step on a rock!" or "You killed [player]"
        // - Add controller support
        // - Add mobile controls
        // - Add boulder & rock variation (6-8 sides)
        // - Add server selector (top)
        // - Add "report an issue" button (under "press enter")
        // - Add Discord button (bottom left)
        // - Add achievements carousel (right half)
        // - Add settings button (top left)
        // - Play button?
        // - SHAKE THE SCREEN WHEN TAKING DAMAGE ON A STEP idk how, maybe the server needs to send a packet telling the player to SHAKE SHAKE SHAKE - 1, 2, SHAKE, SHAKE, 1, 2, SHAKE, SHAKE, ABAaah! eeeaaaeeeuuuaaaaiiioooouuuuueeeuuuooo... GOGOOGLEEE ITTT
        // - Fix death screen to have a custom death msg based on what actually killed you (probably the server needs to store entityJSON.playerDeathReason for the client to use (will say the last entity name that hit the player))
        // - Add debug when pressing I - Show ping and everything
        // - Toggle leaderboard via tab

        //setup shit
        const peer = new Peer(undefined, {
            host: 'peerjs.mikedev101.cc',
            port: 443,
            secure: true,
            config: {
                iceTransportPolicy: "all",
                iceServers: [
                    { urls: "stun:vpn.mikedev101.cc:3478" },
                    { urls: "turn:vpn.mikedev101.cc:3478", username: "free", credential: "free" },
                    { urls: "stun:vpn.mikedev101.cc:5349" },
                    { urls: "turn:vpn.mikedev101.cc:5349", username: "free", credential: "free" },
                ]
            },
            debug: 2
        });

        const app = firebase.initializeApp({
            databaseURL: "https://guessthepin-2fe64-default-rtdb.europe-west1.firebasedatabase.app"
        });
        const database = firebase.database();

        // WE NEED TO GET PEER ID <-- lol I forgot to remove this placeholder comment somehow <-- lol i forgot to remove the placeholder placeholder comment somehow <-- lol i give up on this joke :P
        peer.on('open', (id) => {
            console.log('GIMEMEEE Peer ID:', id)
            window.myPeerId = id
            firstConnect()
        })

        // other

        const canvas = document.getElementById('game')
        const ctx = canvas.getContext('2d')

        let mouseX = 0
        let mouseY = 0
        let leftMouseDown = false
        let rightMouseDown = false

        addEventListener('resize', resize)
        canvas.addEventListener('mousemove', e => {
            mouseX = e.offsetX - canvas.width / 2
            mouseY = e.offsetY - canvas.height / 2
        })
        canvas.addEventListener('mousedown', e => {
            if (e.button === 0) {
                leftMouseDown = true
            } else if (e.button === 2) {
                rightMouseDown = true
            }
        })
        canvas.addEventListener('mouseup', e => {
            if (e.button === 0) {
                leftMouseDown = false
            } else if (e.button === 2) {
                rightMouseDown = false
            }
        })
        canvas.addEventListener('contextmenu', e => {e.preventDefault()})
        
        const keys = {}
        addEventListener('keydown', e => {
            keys[e.key] = true
            if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)) {
                e.preventDefault()
            }
        })
        addEventListener('keyup', e => {
            keys[e.key] = false
        })

        // Helper Functions

        function isKeyPressed(key) {
            return keys[key] === true
        }

        function degToRad(degrees) {
            return degrees * (Math.PI / 180)
        }

        function radToDeg(radians) {
            return radians * (180 / Math.PI)
        }

        function directionTo(newx, newy, oldx, oldy) {
            return radToDeg(Math.atan2(newy - oldy, newx - oldx))
        }

        function distanceTo(newx, newy, oldx, oldy) {
            return Math.sqrt((newx - oldx) ** 2 + (newy - oldy) ** 2)
        }

        function daysSince2000() {
            const startDate = new Date('2000-01-01T00:00:00Z')
            const currentDate = new Date()
            const diffTime = currentDate - startDate
            return Math.floor(diffTime / (1000 * 60 * 60 * 24))
        }

        function randomInt(num1, num2) {return Math.floor(Math.random() * (Math.max(num1, num2) - Math.min(num1, num2) + 1)) + Math.min(num1, num2)}
        function randomFloat(num1, num2) {return Math.random() * (Math.max(num1, num2) - Math.min(num1, num2)) + Math.min(num1, num2)}

        function waitUntil(condition, interval = 100) {
            return new Promise(resolve => {
                const check = () => {
                    if (condition()) {
                        resolve()
                    } else {
                        setTimeout(check, interval)
                    }
                }
                check()
            })
        }

        function clamp(value, min, max) {
            return Math.max(min, Math.min(max, value))
        }

        // Specific Functions

        function setKey(key, value) {
            database.ref('pin/' + key).set(value)
        }

        async function getKey(key) {
            const snapshot = await database.ref('pin/' + key).once('value')
            return snapshot.val()
        }

        function sendData(peerID, type, data, data2, data3, data4, data5) {
            const randomID = randomInt(1000000000000000, 9999999999999999)
            const message = {
                opcode: "P_MSG",
                payload: JSON.stringify([type, randomID, data, data2, data3, data4, data5])
            }
            
            if (conn && conn.open) {
                conn.send(JSON.stringify(message))
                return true
            } else {
                return false
            }
        }

        async function spawnPlayer() {
            console.log('Connected to server!')
            await waitUntil(() => playerID >= 0, 50)
            sendData(serverULID, 'spawnPlayer', playerID)
            menu = 0
            deathScreen = 0
            await waitUntil(() => entityJSON.playerHP && entityJSON.playerHP[playerID] > 0, 50)
        }

        async function firstConnect() {
            console.log(`first connect function ran`)
            // pick the first server bc what else will i do bro
            // in the future do ping tests and pick the best one ig
            serverList = await getKey('cobbled_serverList')
            serverName = serverList[1]
            serverJSON = await getKey(`${serverName}_config`)
            serverJSON = JSON.parse(serverJSON)
            serverULID = await getKey(`${serverName}_ULID`)
            connectToServer(serverULID)
            console.log(`Found server! list: ${serverList} name: ${serverName} json: ${JSON.stringify(serverJSON)} ulid: ${serverULID}`)
        }

        function connectToServer(serverULID) {
            disconnectReason = 'none'
            disconnectWasFromServer = false
            conn = peer.connect(serverULID)

            peer.on('error', (err) => {
                console.log('Peer connection error:', err)
                disconnectReason = 'Failed to connect to server'
                disconnectWasFromServer = false
            })
            
            conn.on('open', () => {
                cameraTargetX = randomInt(-serverJSON.borderSize, serverJSON.borderSize)
                cameraTargetY = randomInt(-serverJSON.borderSize, serverJSON.borderSize)
            })
            
            conn.on('data', (data) => {
                try {
                    const message = JSON.parse(data)
                    if (message.opcode === "P_MSG") {
                        const [type, randomID, entityData, serverPackage] = JSON.parse(message.payload)
                        
                        if (type === "entityData") {
                            entityJSON = entityData
                            playerID = serverPackage.ID
                            stats = serverPackage.stats
                        } else if (type === 'disconnect') {
                            playerID = -1
                            disconnectReason = serverPackage
                            disconnectWasFromServer = true
                        }
                    }
                } catch (err) {
                    console.log('Parse error:', err)
                }
            })
            
            conn.on('error', (err) => {
                console.log('Connection error:', err)
                disconnectReason = 'Disconnected from server'
                disconnectWasFromServer = false
            })
        }

        // Drawing Functions

        function drawRect(x,y,sizex,sizey,dir,fill,outline,thickness) {
            ctx.fillStyle = fill
            ctx.strokeStyle = outline
            ctx.lineWidth = thickness

            ctx.save()
            ctx.translate(x, y)
            ctx.rotate(degToRad(dir))
            ctx.fillRect(0-(sizex/2), 0-(sizey/2), sizex, sizey,)
            if (thickness > 0) ctx.strokeRect(0-(sizex/2), 0-(sizey/2), sizex, sizey,)
            ctx.restore()

        }

        function drawRectHTML(element, x, y, sizex, sizey, dir, fill, outline, thickness) {
            const canvasRect = canvas.getBoundingClientRect()
            const centerX = canvasRect.width / 2
            const centerY = canvasRect.height / 2
            
            const screenX = Math.round(centerX + (x * scale))
            const screenY = Math.round(centerY + (y * scale))
            const screenWidth = Math.round(sizex * scale)
            const screenHeight = Math.round(sizey * scale)
            
            element.style.left = (screenX - Math.round(screenWidth/2)) + 'px'
            element.style.top = (screenY - Math.round(screenHeight/2)) + 'px'
            element.style.width = screenWidth + 'px'
            element.style.height = screenHeight + 'px'
            
            element.style.backgroundColor = fill || 'transparent'
            element.style.border = thickness > 0 ? `${thickness * scale}px solid ${outline}` : 'none'
            element.style.transform = `rotate(${dir}deg)`
            element.style.boxSizing = 'border-box'
            element.style.margin = '0'
            element.style.padding = '0'
            element.style.position = 'absolute'
            
            if (element.tagName === 'INPUT') {
                element.style.textAlign = 'center'
            }
        }

        function drawShape(x, y, radius, sides, dir, fill, outline, thickness) {
            ctx.fillStyle = fill
            ctx.strokeStyle = outline
            ctx.lineWidth = thickness

            ctx.save()
            ctx.translate(x, y)
            ctx.rotate(degToRad(dir))

            ctx.beginPath()
            for (let i = 0; i < sides; i++) {
                const angle = (i / sides) * Math.PI * 2
                const px = Math.cos(angle) * radius
                const py = Math.sin(angle) * radius
                if (i == 0) ctx.moveTo(px, py)
                else ctx.lineTo(px, py)
            }
            ctx.closePath()
            ctx.fill()
            if (thickness > 0) ctx.stroke()
            ctx.restore()
        }


        function drawCircle(x, y, radius, dir, fill, outline, thickness) {
            ctx.fillStyle = fill
            ctx.strokeStyle = outline
            ctx.lineWidth = thickness

            ctx.save()
            ctx.translate(x, y)
            ctx.rotate(degToRad(dir))
            ctx.beginPath()
            ctx.arc(0, 0, radius, 0, Math.PI*2)
            ctx.closePath()
            ctx.fill()
            if (thickness > 0) ctx.stroke()
            ctx.restore()
        }

        function drawLine(x, y, xPoints, yPoints, dir, fill, outline, thickness, closed=false) {
            ctx.fillStyle = fill
            ctx.strokeStyle = outline
            ctx.lineWidth = thickness

            ctx.save()
            ctx.translate(x, y)
            ctx.rotate(degToRad(dir))
            ctx.beginPath()

            ctx.moveTo(xPoints[0], yPoints[0])
            for (let i = 1; i < xPoints.length; i++) {
                ctx.lineTo(xPoints[i], yPoints[i])
            }

            if (closed) ctx.closePath()
            ctx.fill()
            if (thickness > 0) ctx.stroke()
            ctx.restore()
        }

        function drawText(x, y, size, color, text, dir = 0, align = 'center', font = 'Arial') {
            ctx.save()
            ctx.fillStyle = color
            ctx.font = `${size}px ${font}`
            ctx.textAlign = align
            ctx.textBaseline = 'middle'
            ctx.translate(x, y)
            ctx.rotate(degToRad(dir))
            ctx.fillText(text, 0, 0)
            ctx.restore()
        }

        function drawSquircle(x, y, width, height, rotation = 0, fillColor = '', strokeColor = '', lineWidth = 0, cornerRadius = 10) {
            ctx.save()
            ctx.translate(x, y)
            ctx.rotate(degToRad(rotation))
            const halfWidth = width / 2
            const halfHeight = height / 2
            
            ctx.beginPath()
            ctx.moveTo(-halfWidth + cornerRadius, -halfHeight)
            ctx.lineTo(halfWidth - cornerRadius, -halfHeight)
            ctx.quadraticCurveTo(halfWidth, -halfHeight, halfWidth, -halfHeight + cornerRadius)
            ctx.lineTo(halfWidth, halfHeight - cornerRadius)
            ctx.quadraticCurveTo(halfWidth, halfHeight, halfWidth - cornerRadius, halfHeight)
            ctx.lineTo(-halfWidth + cornerRadius, halfHeight)
            ctx.quadraticCurveTo(-halfWidth, halfHeight, -halfWidth, halfHeight - cornerRadius)
            ctx.lineTo(-halfWidth, -halfHeight + cornerRadius)
            ctx.quadraticCurveTo(-halfWidth, -halfHeight, -halfWidth + cornerRadius, -halfHeight)
            ctx.closePath()
            
            if (fillColor) {
                ctx.fillStyle = fillColor
                ctx.fill()
            }
            if (strokeColor && lineWidth > 0) {
                ctx.strokeStyle = strokeColor
                ctx.lineWidth = lineWidth
                ctx.stroke()
            }
            
            ctx.restore()
        }

        // Other Functions

        function resize() {
        canvas.width = innerWidth
        canvas.height = innerHeight
        }

        // init
        serverList = {}
        entityJSON = {}
        playerJSON = {
            level: 0,
            missCounter: 0,
            deathCounter: 0,
            footGoingUp: 1,
            activeFoot: 0,
            ticksSinceLastStep: 0,
            stepping: 0,
            mode: 0, // 0 is normal, -1 is slower, 1 is faster
            stopped: 0,
            upgradeKey: -1,
        }
        achievements = {
            AchievementProgress: [],
            AchievementAchieved: [],
        }
        stats = {
            passiveRegen: 0,
            activeRegen: 0,
            maxHealth: 0,
            kickSpeed: 0,
            kickAccuracy: 0,
            kickDamage: 0,
            duplication: 0,
            stepSpeed: 0,
            stepReach: 0,
            fieldOfView: 0
        }
        notifications = {
            text: [],
            color: [],
            timer: [],
        }
        xpPerLevel = [0,5,15,26,40,64,102,153,222,310,418,543,678,847,1016,1219,1450,1711,2000,2320,2668,3041,3436,3848,4271,4698,5167,5683,6251,6876,7494,8168,8903,9704,10577,11423,12336,13322,14387,15537,16624,17787,19032,20364,21789,23314,25645,28209,31029,34131,37544,39421,41392,43461,45634,47915,50310,52825,55466,58239,61150,1000000000]
        upgradePointsPerLevel = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,50,51,51,52,52,53,53,54,54,55,90]
        // the 2 above may not be the same as the server, so whenever changing these for the client, also change it for the server
        reversedStatNames = ['fieldOfView','stepReach','stepSpeed','duplication','kickDamage','kickAccuracy','kickSpeed','maxHealth','activeRegen','passiveRegen']
        reversedStatDisplayText = ['Field of View [0]','Step Reach [9]','Step Speed [8]','Duplication [7]','Kick Damage [6]','Kick Accuracy [5]','Kick Speed [4]','Max Health [3]','Active Regen [2]','Passive Regen [1]']
        reversedStatColors = ['#9966ff', '#ff9966', '#6696ff', '#ffc266', '#ff6666', '#87e65c', '#6696ff', '#9966ff', '#ff6666', '#fc66ff']
        playerX = 0
        playerY = 0
        playerHP = 0
        playerXP = 0
        playerDirection = 0
        playerHeight = 0
        playerSize = 0
        let cameraX = 0
        let cameraY = 0
        let cameraTargetX = 0
        let cameraTargetY = 0
        let cameraSpeed = 0
        let playerID = -1
        fov = 360
        showLeaderboard = true
        percentHP = 0
        percentXP = 0
        lastNotificationID = null
        menu = 1
        deathScreen = 0
        disconnectReason = 'none'
        disconnectWasFromServer = false
        resize()
        let running = true
        startClientLoop()
        startMenuLoop()

        function startClientLoop() {
            setInterval(() => {
                if (!running) return
                // if (playerID >= 0) is used in a lot of places as a way to determine if the player is connected to the server.
                // a lotta stuff shouldn't even try to render or calculate before they connect.
                // But some stuff (like menus) should still render before connecting.
                if (playerID >= 0) {
                    playerX = entityJSON.playerX[playerID]
                    playerY = entityJSON.playerY[playerID]
                    playerHP = entityJSON.playerHP[playerID]
                    playerXP = entityJSON.playerXP[playerID]
                    playerDirection = entityJSON.playerDirection[playerID]
                    playerHeight = entityJSON.playerHeight[playerID]
                    playerSize = entityJSON.playerSize[playerID]

                    for (let l=0; l < xpPerLevel.length; l++) {
                        if (entityJSON.playerXP[playerID] > xpPerLevel[l]) {
                            playerJSON.level = l
                        }
                    }

                    if (isKeyPressed('a') || isKeyPressed('A')) {
                        playerJSON.stopped = 1
                    } else {
                        playerJSON.stopped = 0
                    }
                    playerJSON.mode = 0
                    if (leftMouseDown || isKeyPressed('Control')) {playerJSON.mode = 1}
                    if (rightMouseDown || isKeyPressed('Shift')) {playerJSON.mode = -1}

                    switch (playerJSON.mode) {
                        case -1: playerModeSpeedMultiplier = 0.75
                        case 0: playerModeSpeedMultiplier = 1
                        case 1: playerModeSpeedMultiplier = 1.5
                    }

                    stepReach = 50+(stats.stepReach*5)
                    fov = 360*(1+(stats.fieldOfView/20))

                    if (entityJSON.playerHeight[playerID][0] < entityJSON.playerHeight[playerID][1]) {
                        activeFoot = 1
                        otherFoot = 0
                    } else {
                        activeFoot = 0
                        otherFoot = 1
                    }

                    // main

                    if (playerID >= 0 && menu == 0) {
                        cameraX += (playerX[otherFoot]-cameraX)/5
                        cameraY += (playerY[otherFoot]-cameraY)/5
                    }

                    if (menu == 1) {
                        if (cameraSpeed < 0.5) {
                            cameraSpeed += 0.005
                            cameraX += cameraSpeed*Math.cos(degToRad(directionTo(cameraTargetX, cameraTargetY, cameraX, cameraY)))
                            cameraY += cameraSpeed*Math.sin(degToRad(directionTo(cameraTargetX, cameraTargetY, cameraX, cameraY)))
                        } else if (distanceTo(cameraTargetX, cameraTargetY, cameraX, cameraY) > 50) {
                            cameraX += 0.5*Math.cos(degToRad(directionTo(cameraTargetX, cameraTargetY, cameraX, cameraY)))
                            cameraY += 0.5*Math.sin(degToRad(directionTo(cameraTargetX, cameraTargetY, cameraX, cameraY)))
                        } else if (distanceTo(cameraTargetX, cameraTargetY, cameraX, cameraY) > 10) {
                            cameraX += (distanceTo(cameraTargetX, cameraTargetY, cameraX, cameraY)/100)*Math.cos(degToRad(directionTo(cameraTargetX, cameraTargetY, cameraX, cameraY)))
                            cameraY += (distanceTo(cameraTargetX, cameraTargetY, cameraX, cameraY)/100)*Math.sin(degToRad(directionTo(cameraTargetX, cameraTargetY, cameraX, cameraY)))
                        } else {
                            cameraSpeed = 0
                            cameraTargetX = randomInt(-serverJSON.borderSize, serverJSON.borderSize)
                            cameraTargetY = randomInt(-serverJSON.borderSize, serverJSON.borderSize)
                        }
                    }

                    // upgrading stats
                    playerJSON.upgradeKey = -1
                    for (let i = 1; i <= 10; i++) {
                        const key = i === 10 ? '0' : i.toString()
                        if (isKeyPressed(key)) {
                            playerJSON.upgradeKey = i
                        }
                    }

                    // notifications
                    if (lastNotificationID != entityJSON.serverNotification.id && lastNotificationID != null) {
                        notifications.text.push(entityJSON.serverNotification.text)
                        notifications.color.push(entityJSON.serverNotification.color)
                        notifications.timer.push(30*7)
                    }
                    for (let i=0; i < notifications.text.length; i++) {
                        notifications.timer[i] -= 1
                        if (notifications.timer[i] <= 0) {
                            notifications.text.splice(i, 1)
                            notifications.color.splice(i, 1)
                            notifications.timer.splice(i, 1)
                            i--
                        }
                    }
                    lastNotificationID = entityJSON.serverNotification.id
                }
                

                scale = Math.max(canvas.width / (fov * 16/9), canvas.height / fov)
                let worldMouseX = (mouseX/scale) + cameraX
                let worldMouseY = (mouseY/scale) + cameraY
                
                // render shit
                ctx.clearRect(0, 0, canvas.width, canvas.height)
                ctx.save()
                ctx.translate(canvas.width / 2, canvas.height / 2)

                ctx.scale(scale, scale)

                let screenSizeX = (canvas.width/scale)
                let screenSizeY = (canvas.height/scale)
                
                if (playerID >= 0) {
                    // Grid
                    let gridSize = 10
                    ctx.fillStyle = '#f7f8ff'
                    ctx.fillRect(-screenSizeX/2, -screenSizeY/2, screenSizeX, screenSizeY)
                    ctx.strokeStyle = '#f1f1f6'
                    ctx.lineWidth = 1
                    
                    for (let x = Math.floor((-screenSizeX/2 + cameraX) / gridSize) * gridSize; x < screenSizeX/2 + cameraX; x += gridSize) {
                        let screenX = x - cameraX
                        ctx.beginPath()
                        ctx.moveTo(screenX, -screenSizeY/2)
                        ctx.lineTo(screenX, screenSizeY/2)
                        ctx.stroke()
                    }

                    for (let y = Math.floor((-screenSizeY/2 + cameraY) / gridSize) * gridSize; y < screenSizeY/2 + cameraY; y += gridSize) {
                        let screenY = y - cameraY
                        ctx.beginPath()
                        ctx.moveTo(-screenSizeX/2, screenY)
                        ctx.lineTo(screenSizeX/2, screenY)
                        ctx.stroke()
                    }

                    let darknessColor = '#00000026'
                    let leftWorldEdge = -serverJSON.borderSize-cameraX
                    let rightWorldEdge = serverJSON.borderSize-cameraX
                    let topWorldEdge = -serverJSON.borderSize-cameraY
                    let bottomWorldEdge = serverJSON.borderSize-cameraY

                    if (leftWorldEdge > -screenSizeX/2) {
                        let width = leftWorldEdge-(-screenSizeX/2)
                        drawRect(-screenSizeX/2+width/2, 0, width, screenSizeY, 0, darknessColor, '', 0)
                    }
                    if (rightWorldEdge < screenSizeX/2) {
                        let width = screenSizeX/2-rightWorldEdge
                        drawRect(screenSizeX/2-width/2, 0, width, screenSizeY, 0, darknessColor, '', 0)
                    }
                    if (topWorldEdge > -screenSizeY/2) {
                        let height = topWorldEdge-(-screenSizeY/2)
                        let xStart = Math.max(-screenSizeX/2, leftWorldEdge)
                        let xEnd = Math.min(screenSizeX/2, rightWorldEdge)
                        let width = xEnd-xStart
                        if (width > 0) {
                            drawRect((xStart+xEnd)/2, -screenSizeY/2+height/2, width, height, 0, darknessColor, '', 0)
                        }
                    }
                    if (bottomWorldEdge < screenSizeY/2) {
                        let height = screenSizeY/2-bottomWorldEdge
                        let xStart = Math.max(-screenSizeX/2, leftWorldEdge)
                        let xEnd = Math.min(screenSizeX/2, rightWorldEdge)
                        let width = xEnd-xStart
                        if (width > 0) {
                            drawRect((xStart+xEnd)/2, screenSizeY/2-height/2, width, height, 0, darknessColor, '', 0)
                        }
                    }

                    // Entities - no: en titties :P
                    if (entityJSON.rockX) {
                        for (let i=0; i < entityJSON.rockX.length; i++) {
                            if (entityJSON.rockDuplicated[i] == 1) {
                                drawShape(entityJSON.rockX[i]-cameraX, entityJSON.rockY[i]-cameraY, 7, 7, i, '#777777', '#606060', 2)
                                drawShape(entityJSON.rockX[i]+(Math.cos(degToRad(entityJSON.rockDirection[i]))*5)-cameraX, entityJSON.rockY[i]+(Math.sin(degToRad(entityJSON.rockDirection[i]))*5)-cameraY, 7, 7, i, '#777777', '#606060', 2)
                            } else {
                                drawShape(entityJSON.rockX[i]-cameraX, entityJSON.rockY[i]-cameraY, 7, 7, i, '#777777', '#606060', 2)
                            }
                        }
                    }

                    if (entityJSON.boulderX) {
                        for (let i=0; i < entityJSON.boulderX.length; i++) {
                            if (entityJSON.boulderSpawnCondition[i] == 1) {
                                switch (entityJSON.boulderRarity[i]) {
                                    case 0: drawShape(entityJSON.boulderX[i]-cameraX, entityJSON.boulderY[i]-cameraY, entityJSON.boulderSize[i]/2, 7, i, '#777777', '#606060', 4); break
                                    case 1: drawShape(entityJSON.boulderX[i]-cameraX, entityJSON.boulderY[i]-cameraY, entityJSON.boulderSize[i]/2, 7, i, '#f2f2f2', '#cccccc', 4); break
                                    case 2: drawShape(entityJSON.boulderX[i]-cameraX, entityJSON.boulderY[i]-cameraY, entityJSON.boulderSize[i]/2, 7, i, '#ffbf00', '#d9a300', 4); break
                                    case 3: drawShape(entityJSON.boulderX[i]-cameraX, entityJSON.boulderY[i]-cameraY, entityJSON.boulderSize[i]/2, 7, i, '#58f5db', '#49ccb6', 4); break
                                    case 4: drawShape(entityJSON.boulderX[i]-cameraX, entityJSON.boulderY[i]-cameraY, entityJSON.boulderSize[i]/2, 7, i, '#ff3333', '#d90000', 4); break
                                }
                            } else if (entityJSON.boulderSpawnCondition[i] == 2) {
                                switch (entityJSON.boulderRarity[i]) {
                                    case 0: drawShape(entityJSON.boulderX[i]-cameraX, entityJSON.boulderY[i]-cameraY, entityJSON.boulderSize[i]/2, 7, i, '#777777', '#606060', 8); break
                                    case 1: drawShape(entityJSON.boulderX[i]-cameraX, entityJSON.boulderY[i]-cameraY, entityJSON.boulderSize[i]/2, 7, i, '#f2f2f2', '#cccccc', 8); break
                                    case 2: drawShape(entityJSON.boulderX[i]-cameraX, entityJSON.boulderY[i]-cameraY, entityJSON.boulderSize[i]/2, 7, i, '#ffbf00', '#d9a300', 8); break
                                    case 3: drawShape(entityJSON.boulderX[i]-cameraX, entityJSON.boulderY[i]-cameraY, entityJSON.boulderSize[i]/2, 7, i, '#58f5db', '#49ccb6', 8); break
                                    case 4: drawShape(entityJSON.boulderX[i]-cameraX, entityJSON.boulderY[i]-cameraY, entityJSON.boulderSize[i]/2, 7, i, '#ff3333', '#d90000', 8); break
                                }
                            }
                        }
                    }

                    if (entityJSON.sanctuaryX) {
                        for (let i=0; i < entityJSON.sanctuaryX.length; i++) {
                            drawCircle(entityJSON.sanctuaryX[i]-cameraX, entityJSON.sanctuaryY[i]-cameraY, entityJSON.sanctuarySize[i]/2, i, '#78787833', '#ff0000', 0)
                        }
                    }

                    if (entityJSON.playerX) {
                        for (let i=0; i < entityJSON.playerX.length; i++) {
                            if (entityJSON.playerHP[i] > 0) {
                                if (i == playerID) {
                                    const arrowSize1 = (playerSize*((100+(playerHeight[0]/1.5))/100))/3
                                    const arrowSize2 = (playerSize*((100+(playerHeight[1]/1.5))/100))/3
                                    if (entityJSON.playerHeight[i][0] < entityJSON.playerHeight[i][1]) {
                                        drawRect((playerX[0] + playerX[1])/2 - cameraX, (playerY[0] + playerY[1])/2 - cameraY, distanceTo(playerX[1], playerY[1], playerX[0], playerY[0]), 8, directionTo(playerX[1], playerY[1], playerX[0], playerY[0]), '#ff2626', '#bf1d1d', 1)
                                        
                                        drawCircle(playerX[0]-cameraX, playerY[0]-cameraY, (playerSize*((100+(playerHeight[0]/1.5))/100))/2, playerDirection[0], '#ff2626', '#bf1d1d', 2)
                                        drawRect(playerX[0]-cameraX-Math.cos(degToRad(playerDirection[0]))*((playerSize*((100+(playerHeight[0]/1.5))/100))/4 + (playerSize*((100+(playerHeight[0]/1.5))/100))*-0.2), playerY[0]-cameraY-Math.sin(degToRad(playerDirection[0]))*((playerSize*((100+(playerHeight[0]/1.5))/100))/4 + (playerSize*((100+(playerHeight[0]/1.5))/100))*-0.2), (playerSize*((100+(playerHeight[0]/1.5))/100))/2, (playerSize*((100+(playerHeight[0]/1.5))/100))/4, playerDirection[0], '#bf1d1d', '#ff00ff', 0)
                                        const arrowX1 = playerX[0]-cameraX + Math.cos(degToRad(playerDirection[0])) * ((playerSize*((100+(playerHeight[0]/1.5))/100))/2 - arrowSize1 * 0.7)
                                        const arrowY1 = playerY[0]-cameraY + Math.sin(degToRad(playerDirection[0])) * ((playerSize*((100+(playerHeight[0]/1.5))/100))/2 - arrowSize1 * 0.7)
                                        drawLine(arrowX1, arrowY1, 
                                            [arrowSize1 * 0.1, -arrowSize1 * 0.7, -arrowSize1 * 0.7], 
                                            [0, arrowSize1 * 0.7, -arrowSize1 * 0.7], 
                                            playerDirection[0], '#bf1d1d', '#bf1d1d', 2, true)

                                        drawCircle(playerX[1]-cameraX, playerY[1]-cameraY, (playerSize*((100+(playerHeight[1]/1.5))/100))/2, playerDirection[1], '#ff2626', '#bf1d1d', 2)
                                        drawRect(playerX[1]-cameraX-Math.cos(degToRad(playerDirection[1]))*((playerSize*((100+(playerHeight[1]/1.5))/100))/4 + (playerSize*((100+(playerHeight[1]/1.5))/100))*-0.2), playerY[1]-cameraY-Math.sin(degToRad(playerDirection[1]))*((playerSize*((100+(playerHeight[1]/1.5))/100))/4 + (playerSize*((100+(playerHeight[1]/1.5))/100))*-0.2), (playerSize*((100+(playerHeight[1]/1.5))/100))/2, (playerSize*((100+(playerHeight[1]/1.5))/100))/4, playerDirection[1], '#bf1d1d', '#ff00ff', 0)
                                        const arrowX2 = playerX[1]-cameraX + Math.cos(degToRad(playerDirection[1])) * ((playerSize*((100+(playerHeight[1]/1.5))/100))/2 - arrowSize2 * 0.7)
                                        const arrowY2 = playerY[1]-cameraY + Math.sin(degToRad(playerDirection[1])) * ((playerSize*((100+(playerHeight[1]/1.5))/100))/2 - arrowSize2 * 0.7)
                                        drawLine(arrowX2, arrowY2,
                                            [arrowSize2 * 0.1, -arrowSize2 * 0.7, -arrowSize2 * 0.7],
                                            [0, arrowSize2 * 0.7, -arrowSize2 * 0.7],
                                            playerDirection[1], '#bf1d1d', '#bf1d1d', 2, true)
                                    } else {
                                        drawRect((playerX[0] + playerX[1])/2 - cameraX, (playerY[0] + playerY[1])/2 - cameraY, distanceTo(playerX[1], playerY[1], playerX[0], playerY[0]), 8, directionTo(playerX[1], playerY[1], playerX[0], playerY[0]), '#ff2626', '#bf1d1d', 1)
                                        
                                        drawCircle(playerX[1]-cameraX, playerY[1]-cameraY, (playerSize*((100+(playerHeight[1]/1.5))/100))/2, playerDirection[1], '#ff2626', '#bf1d1d', 2)
                                        drawRect(playerX[1]-cameraX-Math.cos(degToRad(playerDirection[1]))*((playerSize*((100+(playerHeight[1]/1.5))/100))/4 + (playerSize*((100+(playerHeight[1]/1.5))/100))*-0.2), playerY[1]-cameraY-Math.sin(degToRad(playerDirection[1]))*((playerSize*((100+(playerHeight[1]/1.5))/100))/4 + (playerSize*((100+(playerHeight[1]/1.5))/100))*-0.2), (playerSize*((100+(playerHeight[1]/1.5))/100))/2, (playerSize*((100+(playerHeight[1]/1.5))/100))/4, playerDirection[1], '#bf1d1d', '#ff00ff', 0)
                                        const arrowX2 = playerX[1]-cameraX + Math.cos(degToRad(playerDirection[1])) * ((playerSize*((100+(playerHeight[1]/1.5))/100))/2 - arrowSize2 * 0.7)
                                        const arrowY2 = playerY[1]-cameraY + Math.sin(degToRad(playerDirection[1])) * ((playerSize*((100+(playerHeight[1]/1.5))/100))/2 - arrowSize2 * 0.7)
                                        drawLine(arrowX2, arrowY2,
                                            [arrowSize2 * 0.1, -arrowSize2 * 0.7, -arrowSize2 * 0.7],
                                            [0, arrowSize2 * 0.7, -arrowSize2 * 0.7],
                                            playerDirection[1], '#bf1d1d', '#bf1d1d', 2, true)

                                        drawCircle(playerX[0]-cameraX, playerY[0]-cameraY, (playerSize*((100+(playerHeight[0]/1.5))/100))/2, playerDirection[0], '#ff2626', '#bf1d1d', 2)
                                        drawRect(playerX[0]-cameraX-Math.cos(degToRad(playerDirection[0]))*((playerSize*((100+(playerHeight[0]/1.5))/100))/4 + (playerSize*((100+(playerHeight[0]/1.5))/100))*-0.2), playerY[0]-cameraY-Math.sin(degToRad(playerDirection[0]))*((playerSize*((100+(playerHeight[0]/1.5))/100))/4 + (playerSize*((100+(playerHeight[0]/1.5))/100))*-0.2), (playerSize*((100+(playerHeight[0]/1.5))/100))/2, (playerSize*((100+(playerHeight[0]/1.5))/100))/4, playerDirection[0], '#bf1d1d', '#ff00ff', 0)
                                        const arrowX1 = playerX[0]-cameraX + Math.cos(degToRad(playerDirection[0])) * ((playerSize*((100+(playerHeight[0]/1.5))/100))/2 - arrowSize1 * 0.7)
                                        const arrowY1 = playerY[0]-cameraY + Math.sin(degToRad(playerDirection[0])) * ((playerSize*((100+(playerHeight[0]/1.5))/100))/2 - arrowSize1 * 0.7)
                                        drawLine(arrowX1, arrowY1,
                                            [arrowSize1 * 0.1, -arrowSize1 * 0.7, -arrowSize1 * 0.7],
                                            [0, arrowSize1 * 0.7, -arrowSize1 * 0.7],
                                            playerDirection[0], '#bf1d1d', '#bf1d1d', 2, true)
                                    }
                                } else {
                                    const arrowSize1 = (entityJSON.playerSize[i]*((100+(entityJSON.playerHeight[i][0]/1.5))/100))/3
                                    const arrowSize2 = (entityJSON.playerSize[i]*((100+(entityJSON.playerHeight[i][1]/1.5))/100))/3
                                    if (entityJSON.playerHeight[i][0] < entityJSON.playerHeight[i][1]) {
                                        drawRect((entityJSON.playerX[i][0] + entityJSON.playerX[i][1])/2 - cameraX, (entityJSON.playerY[i][0] + entityJSON.playerY[i][1])/2 - cameraY, distanceTo(entityJSON.playerX[i][1], entityJSON.playerY[i][1], entityJSON.playerX[i][0], entityJSON.playerY[i][0]), 8, directionTo(entityJSON.playerX[i][1], entityJSON.playerY[i][1], entityJSON.playerX[i][0], entityJSON.playerY[i][0]), '#2626ff', '#1d1dbf', 1)
                                        drawCircle(entityJSON.playerX[i][0]-cameraX, entityJSON.playerY[i][0]-cameraY, (entityJSON.playerSize[i]*((100+(entityJSON.playerHeight[i][0]/1.5))/100))/2, entityJSON.playerDirection[i][0], '#2626ff', '#1d1dbf', 2)
                                        drawRect(entityJSON.playerX[i][0]-cameraX-Math.cos(degToRad(entityJSON.playerDirection[i][0]))*((entityJSON.playerSize[i]*((100+(entityJSON.playerHeight[i][0]/1.5))/100))/4 + (entityJSON.playerSize[i]*((100+(entityJSON.playerHeight[i][0]/1.5))/100))*-0.2), entityJSON.playerY[i][0]-cameraY-Math.sin(degToRad(entityJSON.playerDirection[i][0]))*((entityJSON.playerSize[i]*((100+(entityJSON.playerHeight[i][0]/1.5))/100))/4 + (entityJSON.playerSize[i]*((100+(entityJSON.playerHeight[i][0]/1.5))/100))*-0.2), (entityJSON.playerSize[i]*((100+(entityJSON.playerHeight[i][0]/1.5))/100))/2, (entityJSON.playerSize[i]*((100+(entityJSON.playerHeight[i][0]/1.5))/100))/4, entityJSON.playerDirection[i][0], '#1d1dbf', '#2626ff', 0)
                                        const arrowX1 = entityJSON.playerX[i][0]-cameraX + Math.cos(degToRad(entityJSON.playerDirection[i][0])) * ((entityJSON.playerSize[i]*((100+(entityJSON.playerHeight[i][0]/1.5))/100))/2 - arrowSize1 * 0.7)
                                        const arrowY1 = entityJSON.playerY[i][0]-cameraY + Math.sin(degToRad(entityJSON.playerDirection[i][0])) * ((entityJSON.playerSize[i]*((100+(entityJSON.playerHeight[i][0]/1.5))/100))/2 - arrowSize1 * 0.7)
                                        drawLine(arrowX1, arrowY1,
                                            [arrowSize1 * 0.1, -arrowSize1 * 0.7, -arrowSize1 * 0.7],
                                            [0, arrowSize1 * 0.7, -arrowSize1 * 0.7],
                                            entityJSON.playerDirection[i][0], '#1d1dbf', '#1d1dbf', 2, true)

                                        drawCircle(entityJSON.playerX[i][1]-cameraX, entityJSON.playerY[i][1]-cameraY, (entityJSON.playerSize[i]*((100+(entityJSON.playerHeight[i][1]/1.5))/100))/2, entityJSON.playerDirection[i][1], '#2626ff', '#1d1dbf', 2)
                                        drawRect(entityJSON.playerX[i][1]-cameraX-Math.cos(degToRad(entityJSON.playerDirection[i][1]))*((entityJSON.playerSize[i]*((100+(entityJSON.playerHeight[i][1]/1.5))/100))/4 + (entityJSON.playerSize[i]*((100+(entityJSON.playerHeight[i][1]/1.5))/100))*-0.2), entityJSON.playerY[i][1]-cameraY-Math.sin(degToRad(entityJSON.playerDirection[i][1]))*((entityJSON.playerSize[i]*((100+(entityJSON.playerHeight[i][1]/1.5))/100))/4 + (entityJSON.playerSize[i]*((100+(entityJSON.playerHeight[i][1]/1.5))/100))*-0.2), (entityJSON.playerSize[i]*((100+(entityJSON.playerHeight[i][1]/1.5))/100))/2, (entityJSON.playerSize[i]*((100+(entityJSON.playerHeight[i][1]/1.5))/100))/4, entityJSON.playerDirection[i][1], '#1d1dbf', '#2626ff', 0)
                                        const arrowX2 = entityJSON.playerX[i][1]-cameraX + Math.cos(degToRad(entityJSON.playerDirection[i][1])) * ((entityJSON.playerSize[i]*((100+(entityJSON.playerHeight[i][1]/1.5))/100))/2 - arrowSize2 * 0.7)
                                        const arrowY2 = entityJSON.playerY[i][1]-cameraY + Math.sin(degToRad(entityJSON.playerDirection[i][1])) * ((entityJSON.playerSize[i]*((100+(entityJSON.playerHeight[i][1]/1.5))/100))/2 - arrowSize2 * 0.7)
                                        drawLine(arrowX2, arrowY2,
                                            [arrowSize2 * 0.1, -arrowSize2 * 0.7, -arrowSize2 * 0.7],
                                            [0, arrowSize2 * 0.7, -arrowSize2 * 0.7],
                                            entityJSON.playerDirection[i][1], '#1d1dbf', '#1d1dbf', 2, true)
                                    } else {
                                        drawRect((entityJSON.playerX[i][0] + entityJSON.playerX[i][1])/2 - cameraX, (entityJSON.playerY[i][0] + entityJSON.playerY[i][1])/2 - cameraY, distanceTo(entityJSON.playerX[i][1], entityJSON.playerY[i][1], entityJSON.playerX[i][0], entityJSON.playerY[i][0]), 8, directionTo(entityJSON.playerX[i][1], entityJSON.playerY[i][1], entityJSON.playerX[i][0], entityJSON.playerY[i][0]), '#2626ff', '#1d1dbf', 1)     
                                        drawCircle(entityJSON.playerX[i][1]-cameraX, entityJSON.playerY[i][1]-cameraY, (entityJSON.playerSize[i]*((100+(entityJSON.playerHeight[i][1]/1.5))/100))/2, entityJSON.playerDirection[i][1], '#2626ff', '#1d1dbf', 2)
                                        drawRect(entityJSON.playerX[i][1]-cameraX-Math.cos(degToRad(entityJSON.playerDirection[i][1]))*((entityJSON.playerSize[i]*((100+(entityJSON.playerHeight[i][1]/1.5))/100))/4 + (entityJSON.playerSize[i]*((100+(entityJSON.playerHeight[i][1]/1.5))/100))*-0.2), entityJSON.playerY[i][1]-cameraY-Math.sin(degToRad(entityJSON.playerDirection[i][1]))*((entityJSON.playerSize[i]*((100+(entityJSON.playerHeight[i][1]/1.5))/100))/4 + (entityJSON.playerSize[i]*((100+(entityJSON.playerHeight[i][1]/1.5))/100))*-0.2), (entityJSON.playerSize[i]*((100+(entityJSON.playerHeight[i][1]/1.5))/100))/2, (entityJSON.playerSize[i]*((100+(entityJSON.playerHeight[i][1]/1.5))/100))/4, entityJSON.playerDirection[i][1], '#1d1dbf', '#2626ff', 0)
                                        const arrowX2 = entityJSON.playerX[i][1]-cameraX + Math.cos(degToRad(entityJSON.playerDirection[i][1])) * ((entityJSON.playerSize[i]*((100+(entityJSON.playerHeight[i][1]/1.5))/100))/2 - arrowSize2 * 0.7)
                                        const arrowY2 = entityJSON.playerY[i][1]-cameraY + Math.sin(degToRad(entityJSON.playerDirection[i][1])) * ((entityJSON.playerSize[i]*((100+(entityJSON.playerHeight[i][1]/1.5))/100))/2 - arrowSize2 * 0.7)
                                        drawLine(arrowX2, arrowY2,
                                            [arrowSize2 * 0.1, -arrowSize2 * 0.7, -arrowSize2 * 0.7],
                                            [0, arrowSize2 * 0.7, -arrowSize2 * 0.7],
                                            entityJSON.playerDirection[i][1], '#1d1dbf', '#1d1dbf', 2, true)

                                        drawCircle(entityJSON.playerX[i][0]-cameraX, entityJSON.playerY[i][0]-cameraY, (entityJSON.playerSize[i]*((100+(entityJSON.playerHeight[i][0]/1.5))/100))/2, entityJSON.playerDirection[i][0], '#2626ff', '#1d1dbf', 2)
                                        drawRect(entityJSON.playerX[i][0]-cameraX-Math.cos(degToRad(entityJSON.playerDirection[i][0]))*((entityJSON.playerSize[i]*((100+(entityJSON.playerHeight[i][0]/1.5))/100))/4 + (entityJSON.playerSize[i]*((100+(entityJSON.playerHeight[i][0]/1.5))/100))*-0.2), entityJSON.playerY[i][0]-cameraY-Math.sin(degToRad(entityJSON.playerDirection[i][0]))*((entityJSON.playerSize[i]*((100+(entityJSON.playerHeight[i][0]/1.5))/100))/4 + (entityJSON.playerSize[i]*((100+(entityJSON.playerHeight[i][0]/1.5))/100))*-0.2), (entityJSON.playerSize[i]*((100+(entityJSON.playerHeight[i][0]/1.5))/100))/2, (entityJSON.playerSize[i]*((100+(entityJSON.playerHeight[i][0]/1.5))/100))/4, entityJSON.playerDirection[i][0], '#1d1dbf', '#2626ff', 0)
                                        const arrowX1 = entityJSON.playerX[i][0]-cameraX + Math.cos(degToRad(entityJSON.playerDirection[i][0])) * ((entityJSON.playerSize[i]*((100+(entityJSON.playerHeight[i][0]/1.5))/100))/2 - arrowSize1 * 0.7)
                                        const arrowY1 = entityJSON.playerY[i][0]-cameraY + Math.sin(degToRad(entityJSON.playerDirection[i][0])) * ((entityJSON.playerSize[i]*((100+(entityJSON.playerHeight[i][0]/1.5))/100))/2 - arrowSize1 * 0.7)
                                        drawLine(arrowX1, arrowY1,
                                            [arrowSize1 * 0.1, -arrowSize1 * 0.7, -arrowSize1 * 0.7],
                                            [0, arrowSize1 * 0.7, -arrowSize1 * 0.7],
                                            entityJSON.playerDirection[i][0], '#1d1dbf', '#1d1dbf', 2, true)
                                    }
                                }
                            }                        
                        }
                    }


                    let barX = 0
                    let barY = 0
                    let barPositionX = 0
                    let barPositionY = 0
                    let fillX = 0
                    let fillY = 0
                    let percent = 0

                    // Health Bars
                    if (entityJSON.boulderX) {
                        for (let i=0; i < entityJSON.boulderX.length; i++) {
                            if (entityJSON.boulderHP[i] != entityJSON.boulderOriginalHP[i]) {
                                barX = 48*0.75
                                barY = 8*0.75
                                barPositionX = entityJSON.boulderX[i]-cameraX
                                barPositionY = entityJSON.boulderY[i]+((entityJSON.boulderSize[i]/2)+5)-cameraY
                                fillX = 46*0.75
                                fillY = 6*0.75
                                percent = clamp(entityJSON.boulderHP[i]/entityJSON.boulderOriginalHP[i], 0, 1)
                                drawSquircle(barPositionX, barPositionY, barX, barY, 0, '#000000', '#ff00ff', 0, 1*(fov/360))
                                drawSquircle(barPositionX-(fillX/2)*(1-percent), barPositionY, fillX*percent, fillY, 0, '#ff0d0d', '#000000', 0, 1*(fov/360))
                            }
                        }
                    }
                    if (entityJSON.sanctuaryX) {
                        for (let i=0; i < entityJSON.sanctuaryX.length; i++) {
                            if (entityJSON.sanctuaryHP[i] != entityJSON.sanctuaryOriginalHP[i]) {
                                barX = 48*0.75
                                barY = 8*0.75
                                barPositionX = entityJSON.sanctuaryX[i]-cameraX
                                barPositionY = entityJSON.sanctuaryY[i]+((entityJSON.sanctuarySize[i]/2)+5)-cameraY
                                fillX = 46*0.75
                                fillY = 6*0.75
                                percent = clamp(entityJSON.sanctuaryHP[i]/entityJSON.sanctuaryOriginalHP[i], 0, 1)
                                drawSquircle(barPositionX, barPositionY, barX, barY, 0, '#000000', '#ff00ff', 0, 1*(fov/360))
                                drawSquircle(barPositionX-(fillX/2)*(1-percent), barPositionY, fillX*percent, fillY, 0, '#787878', '#000000', 0, 1*(fov/360))
                            }
                        }
                    }
                    if (entityJSON.playerX) {
                        for (let i=0; i < entityJSON.playerX.length; i++) {
                            if (entityJSON.playerHP[i] > 0) {
                                barX = 48*0.75
                                barY = 8*0.75
                                let lowestFoot = entityJSON.playerY[i][0] < entityJSON.playerY[i][1] ? 1 : 0
                                let highestFoot = entityJSON.playerY[i][0] < entityJSON.playerY[i][1] ? 0 : 1
                                barPositionX = entityJSON.playerX[i][lowestFoot]-cameraX
                                barPositionY = entityJSON.playerY[i][lowestFoot]+((entityJSON.playerSize[i]/2)+7)-cameraY
                                fillX = 46*0.75
                                fillY = 6*0.75
                                percent = clamp(entityJSON.playerHP[i]/entityJSON.playerOriginalHP[i], 0, 1)
                                drawSquircle(barPositionX, barPositionY, barX, barY, 0, '#000000', '#ff00ff', 0, 1*(fov/360))
                                drawSquircle(barPositionX-(fillX/2)*(1-percent), barPositionY, fillX*percent, fillY, 0, '#ff0d0d', '#000000', 0, 1*(fov/360))
                                namePositionX = entityJSON.playerX[i][highestFoot]-cameraX
                                namePositionY = entityJSON.playerY[i][highestFoot]-((entityJSON.playerSize[i]/2)+7)-cameraY
                                drawText(namePositionX, namePositionY-6, 8, '#000000', `${entityJSON.playerUsername ? entityJSON.playerUsername[i] : 'unknown name??? BUG'}`, 0, 'center')
                                drawText(namePositionX, namePositionY, 6, '#000000', `${entityJSON.playerXP ? entityJSON.playerXP[i] : 'unknown xp??? BUG'} XP`, 0, 'center')
                            }
                        }
                    }

                    // HUD
                    barX = 48*3*(fov/360)
                    barY = 8*3*(fov/360)
                    barPositionX = 0
                    barPositionY = screenSizeY/2-(barY/2)
                    fillX = 46*3*(fov/360)
                    fillY = 6*3*(fov/360)
                    targetPercentHP = clamp(playerHP/(150+(playerJSON.level*6)+(stats.maxHealth*60)), 0.015, 1)
                    percentHP += (targetPercentHP-percentHP)*0.2
                    drawSquircle(barPositionX, barPositionY, barX, barY, 0, '#000000', '#ff00ff', 0, 2*(fov/360))
                    drawSquircle(barPositionX-(fillX/2)*(1-percentHP), barPositionY, fillX*percentHP, fillY, 0, '#ff0d0d', '#000000', 0, 2*(fov/360))
                    drawText(barPositionX, barPositionY, 10*(fov/360), '#ffffff', `${Math.floor(playerHP*100)/100} HP`, 0, 'center')

                    barX = 48*2*(fov/360)
                    barY = 8*2*(fov/360)
                    barPositionX = 0 
                    barPositionY = screenSizeY/2-(barY/2)-((7*3*(fov/360)))
                    fillX = 46*2*(fov/360)
                    fillY = 6*2*(fov/360)
                    targetPercentXP = clamp((playerXP-xpPerLevel[playerJSON.level])/(xpPerLevel[playerJSON.level]-xpPerLevel[playerJSON.level-1]), 0.02, 0.98)
                    percentXP += (targetPercentXP-percentXP)*0.1
                    if (playerJSON.level == 0) {percentXP = playerXP == 0 ? 0.02 : clamp(playerXP/xpPerLevel[1], 0.02, 0.98)}
                    drawSquircle(barPositionX, barPositionY, barX, barY, 0, '#000000', '#ff00ff', 0, 2*(fov/360))
                    drawSquircle(barPositionX-(fillX/2)*(1-percentXP), barPositionY, fillX*percentXP, fillY, 0, '#ff5d0d', '#000000', 0, 2*(fov/360))
                    drawText(barPositionX, barPositionY, 10*(fov/360), '#ffffff', `Level ${playerJSON.level} - ${Math.floor(playerXP)} XP`, 0, 'center')

                    let minimapSizeX = 70*(fov/360)
                    let minimapSizeY = 70*(fov/360)
                    let minimapPositionX = screenSizeX/2-(minimapSizeX/2)
                    let minimapPositionY = screenSizeY/2-(minimapSizeY/2)
                    let playerMapX = minimapPositionX+((playerX[otherFoot]+playerX[activeFoot])/2)/((serverJSON.borderSize)/(minimapSizeX/2))
                    let playerMapY = minimapPositionY+((playerY[otherFoot]+playerY[activeFoot])/2)/((serverJSON.borderSize)/(minimapSizeY/2))
                    drawSquircle(minimapPositionX, minimapPositionY, minimapSizeX, minimapSizeY, 0, '#82828240', '#c2c2c240', 2, 2*(fov/360))
                    drawShape(playerMapX, playerMapY, 2.5*(fov/360), 3, playerDirection[activeFoot], '#000000', 'ff00ff', 0)
                    if (entityJSON.sanctuaryX) {
                        for (let i=0; i < entityJSON.sanctuaryX.length; i++) {
                            playerMapX = minimapPositionX+(entityJSON.sanctuaryX[i])/((serverJSON.borderSize)/(minimapSizeX/2))
                            playerMapY = minimapPositionY+(entityJSON.sanctuaryY[i])/((serverJSON.borderSize)/(minimapSizeY/2))
                            drawShape(playerMapX, playerMapY, 2.5*(fov/360), 100, playerDirection[activeFoot], '#78787833', 'ff00ff', 0)
                        }
                    }

                    let totalUpgradePoints = Object.values(stats).reduce((sum, val) => sum + val, 0)
                    let upgradePoints = upgradePointsPerLevel[playerJSON.level] - totalUpgradePoints
                    if (upgradePoints != 0 || isKeyPressed('m') || isKeyPressed('M') || deathScreen == 1) {
                        for (let i=0; i < 10; i++) {
                            barX = (96*(fov/360))
                            barY = 10*(fov/360)
                            barPositionX = -(screenSizeX/2-(barX/2))+(2*(fov/360))
                            barPositionY = screenSizeY/2-(barY/2)-(i*12*(fov/360))-(2*(fov/360))
                            fillX = 94*(fov/360)
                            fillY = 8*(fov/360)
                            drawSquircle(barPositionX, barPositionY, barX, barY, 0, '#000000', '#ff00ff', 0, 2*(fov/360))
                            
                            for (let s=0; s < 10; s++) {
                                if (stats[reversedStatNames[i]] > s) {
                                    statX = 69/9*(fov/360)
                                    statPositionX = barPositionX+(s*(statX+1*(fov/360)))-(barX/2)+(statX/2)+1*(fov/360)
                                    drawSquircle(statPositionX, barPositionY, statX, fillY, 0, reversedStatColors[i], '#ff00ff', 0, 1*(fov/360))
                                }
                            }
                            plusButtonX = 16*(fov/360)
                            plusButtonPositionX = barPositionX+(fillX/2)-(plusButtonX/2)
                            drawSquircle(plusButtonPositionX, barPositionY, plusButtonX, fillY, 0, reversedStatColors[i], '#ff00ff', 0, 1*(fov/360))

                            drawText((barPositionX)-(plusButtonX/2)-3, barPositionY, 6*(fov/360), '#ffffff', reversedStatDisplayText[i].slice(0, -4), 0, 'center')
                            drawText((barPositionX+(barX/2))-(plusButtonX)-3, barPositionY, 6*(fov/360), '#ffffff', reversedStatDisplayText[i].slice(-3), 0, 'right')
                            
                        }
                        drawText((barPositionX+(barX/2))-5, barPositionY-15, 20*(fov/360), '#000000', `${upgradePoints}x`, 0, 'right')
                    }

                    let leaderboard = []
                        if (showLeaderboard) {
                            for (let i = 0; i < entityJSON.playerX.length; i++) {
                                if (entityJSON.playerActive[i] && entityJSON.playerXP[i] > 0 && entityJSON.playerHP[i] > 0) {
                                    leaderboard.push({
                                        name: entityJSON.playerUsername[i] || 'unnamed',
                                        xp: entityJSON.playerXP[i],
                                        id: i
                                    })
                                }
                            }
                            
                            leaderboard.sort((a, b) => b.xp - a.xp)
                            leaderboard = leaderboard.slice(0, 10)
                            
                            let barX = (96*(fov/360))
                            let barY = 10*(fov/360)
                            let fillX = 94*(fov/360)
                            let fillY = 8*(fov/360)
                            let barPositionX = screenSizeX/2 - barX - (2*(fov/360))
                            let barPositionY = -screenSizeY/2 + barY + (2*(fov/360))
                            let maxXP = leaderboard.length > 0 ? leaderboard[0].xp : 1
                            drawSquircle(barPositionX + barX/2, barPositionY, barX, barY, 0, '#000000', '#ff00ff', 0, 2*(fov/360))
                            drawText(barPositionX + barX/2, barPositionY, 8*(fov/360), '#ffffff', 'LEADERBOARD', 0, 'center')
                            
                            for (let i = 0; i < leaderboard.length; i++) {
                                let player = leaderboard[i]
                                barPositionY = barPositionY + ((i+1) * 12*(fov/360))
                                let percent = clamp(player.xp / maxXP, 0.02, 1)
                                drawSquircle(barPositionX + barX/2, barPositionY, barX, barY, 0, '#000000', '#ff00ff', 0, 2*(fov/360))
                                drawSquircle(barPositionX + barX/2 - (fillX/2)*(1-percent), barPositionY, fillX*percent, fillY, 0, '#ff5d0d', '#000000', 0, 1*(fov/360))
                                drawText(barPositionX + 5, barPositionY, 6*(fov/360), '#ffffff', `${i+1}. ${player.name}`, 0, 'left')
                                drawText(barPositionX + barX - 5, barPositionY, 6*(fov/360), '#ffffff', `${player.xp} XP`, 0, 'right')
                            }
                        }


                    for (let i=0; i < notifications.text.length; i++) {
                        drawText(0, (i+1)*12*(fov/360)-(screenSizeY/2), 10*(fov/360), notifications.color[i], notifications.text[i], 0, 'center')
                    }
                }
                

                // Menus
                if (deathScreen == 1) {
                    drawRect(0, 0, screenSizeX*(fov/360), screenSizeY*(fov/360), 0, '#00000080', 0, 0)
                    drawText(0, -50*(fov/360), 20*(fov/360), '#000000', `You failed to step on a rock`, 0, 'center')
                    drawText(0, 0, 75*(fov/360), '#ff0000', `YOU DIED`, 0, 'center')
                    drawText(0, 40*(fov/360), 16*(fov/360), '#000000', `Press Enter to respawn`, 0, 'center')
                    let respawnLevel = 0
                    for (let l = 0; l < xpPerLevel.length; l++) {
                        if (Math.min(playerXP / 10, xpPerLevel[24]) >= xpPerLevel[l]) {
                            respawnLevel = l
                        }
                    }
                    drawText(0, 55*(fov/360), 8*(fov/360), '#000000', `You will respawn at level ${respawnLevel}`, 0, 'center')
                }
                
                if (menu == 1) {
                    let input = document.getElementById('usernameInput')
                    input.style.display = 'block'
                    
                    drawRectHTML(input, 0, 0, 200*(fov/360), 22*(fov/360), 0, '#ffffff', '#bfbfbf', 2)
                    input.style.fontSize = (16*(fov/360)*scale) + 'px'
                    
                    if (playerID >= 0) {
                        drawRect(0, 0, screenSizeX*(fov/360), screenSizeY*(fov/360), 0, '#00000080', 0, 0)
                        drawText(0, -22*(fov/360), 16*(fov/360), '#000000', `Connected!`, 0, 'center')
                        drawText(0, 22*(fov/360), 16*(fov/360), '#000000', `Press Enter to play!`, 0, 'center')
                    } else if (disconnectReason == 'none') {
                        drawRect(0, 0, screenSizeX*(fov/360), screenSizeY*(fov/360), 0, '#00000080', 0, 0)
                        drawText(0, -22*(fov/360), 16*(fov/360), '#000000', `Connecting...`, 0, 'center')
                    } else if (disconnectWasFromServer == false) {
                        drawRect(0, 0, screenSizeX*(fov/360), screenSizeY*(fov/360), 0, '#ffdb0080', 0, 0)
                        drawText(0, -22*(fov/360), 16*(fov/360), '#000000', `Failed to connect to server...`, 0, 'center')
                        drawText(0, 22*(fov/360), 16*(fov/360), '#000000', `${disconnectReason}`, 0, 'center')
                    } else if (disconnectWasFromServer == true) {
                        drawRect(0, 0, screenSizeX*(fov/360), screenSizeY*(fov/360), 0, '#62000080', 0, 0)
                        drawText(0, -22*(fov/360), 16*(fov/360), '#000000', `Disconnected!`, 0, 'center')
                        drawText(0, 22*(fov/360), 16*(fov/360), '#000000', `${disconnectReason}`, 0, 'center')
                    }
                    
                    username = input.value || 'unnamed'
                } else {
                    document.getElementById('usernameInput').style.display = 'none'
                }

                ctx.restore()

                if (playerID >= 0) {
                    playerPackage = {
                        worldMouseX: worldMouseX,
                        worldMouseY: worldMouseY,
                        mode: playerJSON.mode,
                        stopped: playerJSON.stopped,
                        upgradeKey: playerJSON.upgradeKey,
                        username: username,
                    }
                    sendData(serverULID, 'playerUpdate', playerID, playerPackage)
                }
                
            }, 33.33)
        }
    
        
        let deathCheckCooldown = false
        let enterWasPressedLastFrame = false

        async function startMenuLoop() {
            setInterval(async () => {
                if (!running) return

                let enterNow = isKeyPressed('Enter')
                let enterPressedThisFrame = !enterWasPressedLastFrame && enterNow
                enterWasPressedLastFrame = enterNow

                if (enterPressedThisFrame) {
                    if (playerID >= 0) {
                        if (deathScreen == 1) {
                            deathScreen = 0
                            menu = 1
                        } else if (menu == 1) {
                            menu = 0
                            deathCheckCooldown = true
                            await spawnPlayer()
                            await waitUntil(() => entityJSON.playerHP[playerID] > 0)
                            setTimeout(() => {deathCheckCooldown = false}, 3000)
                        }
                    } else {
                        connectToServer(serverULID)
                    }
                }
                
                if (entityJSON.playerHP && !deathCheckCooldown && menu == 0) {
                    if (entityJSON.playerHP[playerID] <= 0) {
                        deathScreen = 1
                    }
                }

                if (menu == 1) {
                    deathScreen = 0
                }
            }, 33.33)
        }


    </script>
</body>
</html>
